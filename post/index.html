<!DOCTYPE html>
<html lang="en-us">
<head>
<meta charset="utf-8">
<meta name="description" content="">
<meta name="keywords" content="">
<meta name="author" content="">
<meta name="generator" content="Hugo 0.18.1" />
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://tenderleo.github.io/css/style.css" type="text/css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,700" type="text/css">
<link rel="alternate" href="https://tenderleo.github.io/index.xml" type="application/rss+xml" title="">
<title>Posts - </title>
</head>
<body>

<header>
  <div class="container clearfix">
    <span class="base05">[</span><span class="base08">t</span><span class="base09">e</span><span class="base0a">n</span>.
    <span class="base0b">d</span><span class="base0c">e</span><span class="base0d">r</span><span class="base0f">l</span>.
    <span class="base0d">e</span><span class="base0e">0</span><span class="base05">]</span>
  </div>
  
</header>

<div class="container">

<main role="main" class="article-list">
  <h1 class="list-title">Posts</h1>
  
    
<article class="list-item" itemscope itemtype="http://schema.org/Blog">
  <h2 class="headline" itemprop="headline"><a href="/post/printf/">your own printf</a></h2>
  <div class="meta">

    <span class="key">published on</span>
    <span class="val"><time itemprop="datePublished" datetime="2017-02-27">February 27, 2017</time></span>

  </div>
  <section class="summary">
    library to build printf printf using several function defined inside stdarg.h to build a string on stack, interleaving the string format with your data.
__printf(const char *format, ...) { va_list arg; int done; va_start(arg, format); done = vfprintf(stdout, format, arg); va_end(list); return done; }  va_list the object will hold the list of additional arguments of the function. it will be empty until you initialize it with va_start.
va_start(typename format, &hellip;) va_start initializes an object of this type in such a way that subsequent calls to va_arg sequentially retrieve the additional arguments passed to the function.  <a href="/post/printf/">Read More...</a>
  </section>
</article>

  
    
<article class="list-item" itemscope itemtype="http://schema.org/Blog">
  <h2 class="headline" itemprop="headline"><a href="/post/SFINAE/">SFINAE and std::enable_if</a></h2>
  <div class="meta">

    <span class="key">published on</span>
    <span class="val"><time itemprop="datePublished" datetime="2017-02-25">February 25, 2017</time></span>

  </div>
  <section class="summary">
    SFINAE SFINAE is language feature/idiom short for Substitution failure is not an error.
In the process of template argument deduction, C++ compiler will try its best to initiate signatures of candidate overloaded function to make sure it finds the best/exact overloaded one function signature.
In this process, if an invalid argument/return type is formed, this instantiation is removed from the resolution result set. As long as there is at least one instantiation instance exists in the resolution set, the compiler won&rsquo;t fail the compiling process.  <a href="/post/SFINAE/">Read More...</a>
  </section>
</article>

  
    
<article class="list-item" itemscope itemtype="http://schema.org/Blog">
  <h2 class="headline" itemprop="headline"><a href="/post/hidraw/">hidraw</a></h2>
  <div class="meta">

    <span class="key">published on</span>
    <span class="val"><time itemprop="datePublished" datetime="2017-02-25">February 25, 2017</time></span>

  </div>
  <section class="summary">
     
  </section>
</article>

  
    
<article class="list-item" itemscope itemtype="http://schema.org/Blog">
  <h2 class="headline" itemprop="headline"><a href="/post/type_deduction/">type_deduction</a></h2>
  <div class="meta">

    <span class="key">published on</span>
    <span class="val"><time itemprop="datePublished" datetime="2017-02-23">February 23, 2017</time></span>

  </div>
  <section class="summary">
     the code used to illustrate how type deduction work for template.
template&lt;typename T&gt; void f(ParamType param); void f(expr)  ParamType is a pointer/reference type, but not universal reference. ParamType is a universal reference. ParamType is neither a pointer nor a reference.  
  </section>
</article>

  
    
<article class="list-item" itemscope itemtype="http://schema.org/Blog">
  <h2 class="headline" itemprop="headline"><a href="/post/new_enum_type/">new enum type</a></h2>
  <div class="meta">

    <span class="key">published on</span>
    <span class="val"><time itemprop="datePublished" datetime="2017-02-22">February 22, 2017</time></span>

  </div>
  <section class="summary">
     what is wrong with C++98 enums ?
enumerators have global visibility implicit conversion value type varies Benefits from C++11 enums
scoped enumerators name. strong types designated value type  
  </section>
</article>

  
    
<article class="list-item" itemscope itemtype="http://schema.org/Blog">
  <h2 class="headline" itemprop="headline"><a href="/post/string_literal_type/">string literal type</a></h2>
  <div class="meta">

    <span class="key">published on</span>
    <span class="val"><time itemprop="datePublished" datetime="2017-02-22">February 22, 2017</time></span>

  </div>
  <section class="summary">
    String literal in c++ is of type const array of char. so the following
 char * var = &quot;random string&quot;;  compiler will report
warning: conversion from string literal to &lsquo;char *&rsquo; is deprecated 
  </section>
</article>

  
    
<article class="list-item" itemscope itemtype="http://schema.org/Blog">
  <h2 class="headline" itemprop="headline"><a href="/post/constexpr/">constexpr</a></h2>
  <div class="meta">

    <span class="key">published on</span>
    <span class="val"><time itemprop="datePublished" datetime="2017-02-21">February 21, 2017</time></span>

  </div>
  <section class="summary">
    [7.1.5] the constexpr specifier
Compile-time initialization At machine code level, a variable defines a memory address, and it will always have value at that address, before any user code starts running, the storage for compile-time initialized variable is loaded/laid out with the computed value.
 int x = 1 + 2 + 3;  instead of generating machine code that sums up 1+2+3 and assign the result to x,compiler can compute the result and bind it to x at compile time.  <a href="/post/constexpr/">Read More...</a>
  </section>
</article>

  
    
<article class="list-item" itemscope itemtype="http://schema.org/Blog">
  <h2 class="headline" itemprop="headline"><a href="/post/braced_initialization/">initializer[dcl.init]</a></h2>
  <div class="meta">

    <span class="key">published on</span>
    <span class="val"><time itemprop="datePublished" datetime="2017-02-20">February 20, 2017</time></span>

  </div>
  <section class="summary">
    According [8.2], C++&rsquo;s resolution policy will prefer to consider any construct that could possibly be a declaration a declaration. thus the following statement
 Object object(int());  will be consider a function declaration, instead of creating a new object, even the code intends to create one. This is so-called C++'s most vexing parsing
Initializer syntax Variables can be initialized using
 {}, braces, or = {}, equal braces (), parentheses =, equal sign  {} and std::initializer_list {} binds to std::initializer_list strongly that it will supersede any other forms overloaded methods if implicit conversion applicable, even if the non initializer_list version overload maybe more suitable for the given parameters, compiler will still implicitly convert parameters to the type which initializer_list holds, and call the std::initializer_list version.  <a href="/post/braced_initialization/">Read More...</a>
  </section>
</article>

  
    
<article class="list-item" itemscope itemtype="http://schema.org/Blog">
  <h2 class="headline" itemprop="headline"><a href="/post/my2nd/">my2nd</a></h2>
  <div class="meta">

    <span class="key">published on</span>
    <span class="val"><time itemprop="datePublished" datetime="2017-02-18">February 18, 2017</time></span>

  </div>
  <section class="summary">
     
  </section>
</article>

  
    
<article class="list-item" itemscope itemtype="http://schema.org/Blog">
  <h2 class="headline" itemprop="headline"><a href="/post/welcome/">welcome</a></h2>
  <div class="meta">

    <span class="key">published on</span>
    <span class="val"><time itemprop="datePublished" datetime="2017-02-17">February 17, 2017</time></span>

  </div>
  <section class="summary">
     class this-&gt;  1  #include &lt;iostream&gt; 2  using namespace std; 3  4  class Object { 5  struct name{ 6  7  }; 8  9  }; 10  11  int main(){ 12  std::vector&lt;std::string&gt; names = new std::vector&lt;std::string&gt;(); 13  return 0; 14  }   
  </section>
</article>

  
</main>

</div>

<footer>
  <div class="container">
    <span class="copyright">&copy; 2017   - <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a></span>
  </div>
</footer>

</body>
</html>

